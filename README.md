# Запуск docker compose
Чтобы запустить сразу все окружение, достаточно прописать:
```sh
docker compose up --build
```
Эта команда поднимает БД (Postgres), и запускает проект на [localhost:8000/](localhost:8000/)
Также сразу же доступен swagger: [localhost:8000/swagger](localhost:8000/swagger)

# Билд
Сбилдить проект можно скриптом `./build.sh`
Он создаст папку `target/`, и добавит туда скомпилированный бинарный файл (`main`), и также скопирует директорию с `openapi/openapi.yaml` (для swagger)

# .env
Переменные окружения которые можно настроить содержатся в `.env.example`

# Интеграционные тесты
Для запуска интеграционных тестов используется `tests.docker-compose.yaml` файл с БД и тесты из `tests/integration`

Команды запуска:
```sh
./run_integration_tests.sh

# Либо же можно запустить в несколько команд
# Старт тестовой БД
docker compose -f docker-compose.tests.yaml up --build -d --wait
# Запуск тестов
go test ./tests/integration
# Остановить тестовую БД
docker compose -f docker-compose.tests.yaml down -v
```

# Выбранные решения
## Собственная библиотека для цепочки хендлеров
В проекте использована моя библиотека [stackable](https://pkg.go.dev/github.com/saryginrodion/stackable) для цепочки хендлеров реквестов (работает как некий аналог `express.js`)

Небольшой экскурс в нее:
- Есть цепочка хендлеров (структура `Stackable`). Она реализует интерфейс `Handler` из `net/http`.
- `SharedState` - общее состояние (сохраняется между реквестами).
- `LocalState` - состояние для одного реквеста (с помощью него хендлеры могут передавать данные в цепочке в рамках одного реквеста)
- `Handler` - интерфейс одного хэндлера в цепочке. В него передается `Context` - там лежит `response`, `request`, `SharedState` и `LocalState`, а также функция `next() error` - для вызова следующего хендлера

Цепочка начинается с первого добавленного хендлера и идет до последнего путем вызовов `next()`

## round-robin для переназначения ревьюверов
В ТЗ не было указано, каким образом будут назначаться ревьюверы, поэтому применяется **round robin** метод.

Для этого у каждого пользователя сохраняется поле `LastAssignedAt`, в кототром лежит последнее время назначения этого пользователя на ревью.
При назначении/переназначении пользователи сортируются в порядке возрастания по этому полю, и первыми берутся те, кто не был давно назначен.

## Ограничение: невозможность обновлять состав команды
В приложенном `openapi` есть эндпоинт `/team/add`, который якобы должен использоваться также и для обновления команды (так написано в его описании),
но также в ошибках этого эндпоинта есть `TEAM_EXISTS` код, который показывает, что **команда уже создана**.

Также возможность обновить пользователей именно в такой архитектуре API нелогична - для каждой команды создаются отдельные пользователи, которые привязаны
только к одной команде.

Поэтому для переопределения состава команды ее нужно **создать заново**. Это связано с ограничениями данного API.

## Возможные коды ошибок от сервера
 - PARSE_FAIL: Ошибка при разборе JSON запроса.
 - VALIDATION_FAIL: Ошибка валидации данных запроса.
 - USER_EXISTS_IN_ANOTHER_TEAM: Пользователь уже состоит в другой команде.
 - NOT_FOUND: Запрашиваемый ресурс не найден.
 - TEAM_EXISTS: Команда с таким именем уже существует.
 - PR_EXISTS: Pull request с таким ID уже существует.
 - NO_CANDIDATE: Недостаточно кандидатов для назначения.
 - PR_MERGED: Невозможно переназначить уже слитый pull request.
 - UNKNOWN: Необработанная/неизвестная ошибка сервера.
